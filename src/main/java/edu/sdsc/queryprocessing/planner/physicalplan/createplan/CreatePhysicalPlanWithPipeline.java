package edu.sdsc.queryprocessing.planner.physicalplan.createplan;

import edu.sdsc.datatype.execution.ParallelMode;
import edu.sdsc.datatype.execution.PipelineMode;
import edu.sdsc.queryprocessing.planner.logicalplan.DAGElements.Nodes.*;
import edu.sdsc.queryprocessing.planner.logicalplan.DAGElements.PlanEdge;
import edu.sdsc.queryprocessing.planner.physicalplan.element.PhysicalOperator;
import edu.sdsc.queryprocessing.planner.physicalplan.element.highleveloperators.HighLevelPhysical;
import edu.sdsc.queryprocessing.planner.physicalplan.element.highleveloperators.MapPhysical;
import edu.sdsc.utils.Pair;
import edu.sdsc.variables.logicalvariables.VariableTable;
import org.jgrapht.Graph;
import org.jgrapht.Graphs;
import org.jgrapht.graph.DefaultDirectedGraph;

import javax.json.JsonObject;
import java.io.IOException;
import java.nio.channels.Pipe;
import java.util.*;
import java.util.stream.Collectors;

import static edu.sdsc.queryprocessing.planner.physicalplan.createplan.CreatePhysicalPlan.*;
import static edu.sdsc.queryprocessing.planner.physicalplan.utils.PlanUtils.*;

// todo: need to change the capability of first operator and last operator in the sub-operators list of Map operator
//   the last one has to generate a materialized output and the first one needs to decide if the capability-on variable is the local variable of the Map operator,
//   if so, then needs to change
public class CreatePhysicalPlanWithPipeline {

    private static void  createVarToVertexMap(Set<Pair<Integer, String>> variable, int vID, Map<Pair<Integer, String>, Integer> variable2Vetex) {
        for (Pair<Integer, String> i : variable) {
            variable2Vetex.put(i, vID);
        }
//        return variable2Vetex;
    }

// // add links to parents
//    private static void findParent(Graph<PhysicalOperator, DefaultEdge> g, Map<Pair<Integer, String>, Integer> v2n, PhysicalOperator oprt, Set<Pair<Integer, String>> usedVars) {
//        g.addVertex(oprt);
//        for (Pair<Integer, String> v : usedVars) {
//            Integer nodeID = v2n.get(v);
//            System.out.println(v.first);
//            PhysicalOperator parent = g.vertexSet().stream().filter(opt -> opt.getId().equals(nodeID)).findAny()
//              .get();
//            g.addEdge(parent, oprt);
//        }
////        return g;
//    }

    // ignore the false parents which are sub-operators of HL
    private static Set<PhysicalOperator> getParents(Graph<PhysicalOperator, PlanEdge> g, PhysicalOperator op) {
        Set<PlanEdge> edges = g.incomingEdgesOf(op);
        Set<PhysicalOperator> parents = new HashSet<>();
        for (PlanEdge edge:edges) {
            PhysicalOperator p = g.getEdgeSource(edge);
            if (!p.isSubOperator()) {
                parents.add(p);
            }
        }
        return parents;
    }

    private static Set<PhysicalOperator> getChildren(Graph<PhysicalOperator, PlanEdge> g, PhysicalOperator op) {
        Set<PlanEdge> edges = g.outgoingEdgesOf(op);
        Set<PhysicalOperator> children = new HashSet<>();
        edges.forEach(edge->{children.add(g.getEdgeTarget(edge));});
        return children;
    }

    private static Set<PhysicalOperator> getCapOnChildren(Set<PhysicalOperator> children, PhysicalOperator op) {
        Set<PhysicalOperator> capOnChildren = new HashSet<>();
        Set<Pair<Integer, String>> outputVar = op.getOutputVar();
        // if the child's cap on variable is generated by this operator, then this child's
        for (PhysicalOperator child : children) {
            Pair<Integer, String> capOnVar = child.getCapOnVarID();
            if (capOnVar!= null && outputVar.contains(capOnVar)) {
                capOnChildren.add(child);
            }
        }
        return capOnChildren;
    }


    private static <K, V> void addElementToMapValueSet(Map<K, Set<V>> map, K key, V value) {
        if (map.containsKey(key)) {
            Set<V> temp = map.get(key);
            temp.add(value);
        }
        else {
            Set<V> temp = new HashSet<>();
            temp.add(value);
            map.put(key, temp);
        }
    }





//    public static List<List<PhysicalOperator>> getPipelineWithFusionPlan(Graph<Operator, PlanEdge> g, VariableTable vt, JsonObject config)  throws IOException{
//        Graph<PhysicalOperator, PlanEdge> naiveDAG = getPhysicalPlan(g, vt, config,true, true);
//        fuseHLOs(naiveDAG);
//        return setExecutionMode(naiveDAG);
//        return naiveDAG;
//    }


    // todo: should add high level operators,
    //  should add Operator Fusion for HLOs
    //  the subOperators inside a HLO should be assigned as Blocking capability when not fused
    //  after fusion, should consider the inner subOperators' capabilities
    // first finish the pipeline version without operator fusion. All subOperators' capability should be changed as blocking
    // HLOs itself can hve capability. The input or output can be a stream of MTEs
    // second, add the case when Maps are fused and the inner operator can generate stream of stream. But the chain will
    // output a stream/list of MTE at the end

//    public static List<PhysicalOperator> getPipelinePlan(Graph<Operator, PlanEdge> g, VariableTable vt, JsonObject config, Integer varID) throws IOException {
//        // set the input mode of 1st subOperator and output mode of last operator in a chain in the naive plan part. It will influence
//        //    the parents execution mode decision
//        Graph<PhysicalOperator, PlanEdge> naiveDAG = getPhysicalPlan(g, vt, config, true, true);
//        // set pipeline mode
//        return setExecutionMode(naiveDAG, varID);
//        return naiveDAG;
//    }

// change the capability of sub-operators of Map
    // todo: may change the code to make it simpler
    public static List<List<PhysicalOperator>> setExecutionModes(Graph<PhysicalOperator, PlanEdge> naiveDAG) {
        // add capabilityOn Var/Operator. For an executor, when determine the input mode, only check the capability on's parent.
        // When determine the output mode, for children, if it has stream input but not capability on this, then should consider it as a block
        // for hlo, should change the capability of the last one and the first one. (actually, the first one always take materialized results). the last one can only generate blocking output
//        Map<PhysicalOperator, Set<PhysicalOperator>> parentOperatorWithMode = new HashMap<>();
        // change first and last sub-operator's pipeline capability and all sub-operators' parallelism capability
        // skip all the sub-operators
        List<PhysicalOperator> operations = naiveDAG.vertexSet().stream().sorted(Comparator.comparing(PhysicalOperator::getId))
                .collect(Collectors.toList());
        for (PhysicalOperator op : operations) {
            // for sub-operators of high-level operator, change the parallel capability
            if (op.isSubOperator()) {
                op.setParallelCapability(ParallelMode.sequential);
                if (op.isFirstOpeInChain()) {
                    op.setPipelineCapability(inputStreamBlockingCap(op));
                }
                else if (op.isLastOpeInChain()) {
                    op.setPipelineCapability(outputStreamBlockingCap(op));
                }
            }
        }
        // change the capability of the last operator
        PhysicalOperator temp = operations.get(operations.size()-1);
        if (temp.getPipeCapability().equals(PipelineMode.streamoutput)) {temp.setPipelineCapability(PipelineMode.block);}
        else if (temp.getPipeCapability().equals(PipelineMode.pipeline)) {temp.setPipelineCapability(PipelineMode.streaminput);}
        // todo: consider sub-operators later, for now, only treat a hl operator as one whole
        List<List<PhysicalOperator>> chains = new ArrayList<>();
        // for every operator, see if this was visited, if so, skip
        Set<PhysicalOperator> visited = new HashSet<>();
        for (PhysicalOperator op : operations) {
            if (op.isSubOperator()) {
                continue;
            }
            if (visited.contains(op)) {
                continue;
            }
            visited.add(op);
            List<PhysicalOperator> chain = new ArrayList<>();
            chain.add(op);
            // add child until no pipeline-able child
            while (true) {
                // if this operator can't form a pipeline, skip
                if (op.getPipeCapability() == PipelineMode.streaminput || op.getPipeCapability() == PipelineMode.block) {
                    break;
                }
                Set<PhysicalOperator> children = getChildren(naiveDAG, op);
                Set<PhysicalOperator> capOnChildren = getCapOnChildren(children, op);
                if (children.size() > 1 || capOnChildren.size() != 1) {
                    break;
                }
                PhysicalOperator candidateChild = capOnChildren.iterator().next();
                if (visited.contains(candidateChild)) {
                    break;
                }
                // if the child has more than one parents, do not add, cause it will be related to the order problem
                // todo: may solve the order problem in the future
                Set<PhysicalOperator> parents = getParents(naiveDAG, capOnChildren.iterator().next());
                if (parents.size() > 1) {
                    break;
                }
                boolean addChild = (candidateChild.getPipeCapability().equals(PipelineMode.streaminput)
                        || candidateChild.getPipeCapability().equals(PipelineMode.pipeline))
//                        && (candidateChild.getParallelCapability() == op.getParallelCapability())
                        ;
                if (addChild) {
                    chain.add(candidateChild);
                    op = candidateChild;
                    visited.add(op);
                } else {
                    break;
                }
            }
            if (chain.size()>1) {
                chain.get(0).setExecutionMode(PipelineMode.streamoutput);
                chain.get(chain.size()-1).setExecutionMode(PipelineMode.streaminput);
                for (int i=1; i<chain.size()-1; i++) {
                    // if this is the first operator in the list, then should set a streamOut mode
                    chain.get(i).setExecutionMode(PipelineMode.pipeline);
                }
            } else {
                chain.get(0).setExecutionMode(PipelineMode.block);
            }
            chains.add(chain);
        }
        return chains;
    }
//            boolean streamOutput = false;
//            operationsWithMode.add(op);
//            // if more than one children, streamout = false; if only one child, but the child does not have cap on it or the child take materialize input,
//            // then streamout = false; if only one child, and the child has the same parallelism
//            // find cap on predecessor (normally only one), based on its mode, set the input cap
//            // get cap-on parents to decide the input mode
//            Set<PhysicalOperator> parents = new HashSet<>();
//            // when the parents are processed, it already adds the cap-on-child's ID and the new parent ID to the map, so just need to look up the map
//            if (parentOperatorWithMode.containsKey(op)) {
//                parents = parentOperatorWithMode.get(op);
//            }
//            boolean streamInput = isInputModeStream(op, parents);
//            // get children to determine output mode
//            // get capability-on children and non-capability-on children
//            // if there is no cap child or multiple children, streamOutput = false
//            Set<PhysicalOperator> children = getChildern(naiveDAG, op);
//            if (children.size() == 1) {
//                Set<PhysicalOperator> capOnChildren = getCapOnChildren(children, op);
//                if (capOnChildren.size() == 1) {
//                    // when the child has the same parallelism cap
//                    PhysicalOperator child = capOnChildren.iterator().next();
//                    PipelineMode childMode = child.getPipeCapability();
//                    PipelineMode mode = op.getPipeCapability();
//                    if (op.getParallelCapability() == child.getParallelCapability()
//                            && (mode.equals(PipelineMode.pipeline) || mode.equals(PipelineMode.streamoutput))
//                            && (childMode.equals(PipelineMode.streaminput) || childMode.equals(PipelineMode.pipeline))
//
//                    ) {
//                        addElementToMapValueSet(parentOperatorWithMode, child, op);
//                        streamOutput = true;
//                    }
//                }
//            }
//            if (streamInput && streamOutput) {op.setExecutionMode(PipelineMode.pipeline);}
//            else if (streamInput) {op.setExecutionMode(PipelineMode.streaminput);}
//            else if (streamOutput) {op.setExecutionMode(PipelineMode.streamoutput);}
//            else {op.setExecutionMode(PipelineMode.block);}
//        }
//        return operationsWithMode;
//    }

    // if the current parent is the only possible parent that can form a pipeline, add it
//    private static boolean addChild(PhysicalOperator op, Set<PhysicalOperator> parents, PhysicalOperator currentParent) {
//        boolean addChild = (op.getPipeCapability().equals(PipelineMode.streaminput) || op.getPipeCapability().equals(PipelineMode.pipeline))
//                && (currentParent.getParallelCapability() == op.getParallelCapability());
//        parents.remove(currentParent);
//
//        if (op.getPipeCapability().equals(PipelineMode.streaminput) || op.getPipeCapability().equals(PipelineMode.pipeline)) {
//            for (PhysicalOperator p : parents) {
//                if (p.getExecutionMode().equals(PipelineMode.streamoutput) || p.getExecutionMode().equals(PipelineMode.pipeline)) {
//                    streamInput = true;
//                }
//            }
//        }
//        return streamInput;
//    }


    public static List<PhysicalOperator> buildSubGraphForMap(List<PhysicalOperator> operations, MapPhysical op) {
        List<PhysicalOperator> subGraph = new ArrayList<>();
        PhysicalOperator lastOfPresent = findOpeByID(operations, op.getInputOperator().iterator().next());
        subGraph.add(lastOfPresent);
        while (lastOfPresent.isHasDependentOpe()) {
            PhysicalOperator current = findOpeByID(operations, lastOfPresent.getDependentOpeID());
            subGraph.add(0, current);
            lastOfPresent = current;
        }
        return subGraph;
    }


    // todo: only has Maps now and should consider other HLOs
        // for map, should add sub-operator DAG and sub-operator chains attribute
    public static void fuseHLOs(Graph<PhysicalOperator, PlanEdge> naiveDAG) {
        List<PhysicalOperator> operations = naiveDAG.vertexSet().stream().sorted(Comparator.comparing(PhysicalOperator::getId)).collect(Collectors.toList());
        for (PhysicalOperator op : operations) {
            if (op instanceof HighLevelPhysical) {
                if (op instanceof MapPhysical) {
                    // for each map operator, needs to set the subgraph
                    MapPhysical mapOp = (MapPhysical) op;
                    // build the sub-graph for the current Map
                    List<PhysicalOperator> subGraph = mapOp.getInnerOperators();
                    Set<PhysicalOperator> children = getChildren(naiveDAG, mapOp);
                    if (children.size()==1) {
                        PhysicalOperator child = children.iterator().next();
                        if(child instanceof MapPhysical) {
                            MapPhysical childMap = (MapPhysical) child;
                            List<PhysicalOperator> nextSubGraph = childMap.getInnerOperators();
                            subGraph.addAll(nextSubGraph);
                            // the input of the new map should be the input of the parent map and the output should be the child map's output
                            // let the last one of parent map link to the first one of child
                            PhysicalOperator lastOfPresent = findOpeByID(operations, mapOp.getInputOperator().iterator().next());
                            // last one is the inputOperator, but the first one is the head of dependent operators
                            PhysicalOperator firstOfChild = findOpeByID(operations, ((MapPhysical) child).getInputOperator().iterator().next());
                            while (firstOfChild.isHasDependentOpe()) {
                                firstOfChild = findOpeByID(operations, firstOfChild.getDependentOpeID());
                            }
                            lastOfPresent.setLastOpeInChain(false);
                            // if the maps are fused, the previous Map's output is the current map's input variable, and thus the last sub-operator of the previous map should output
                            // the local variable to the first sub-ope of current map
                            List<Integer> locals = ((MapPhysical) child).getLocalVarID();
                            assert locals.size() == 1;
                            Pair<Integer, String> localVar = new Pair<>(locals.get(0), "*");
                            lastOfPresent.addOutputVar(localVar);
                            firstOfChild.setFirstOpeInChain(false);
                            // should set dependency between the two, and add an edge between them
                            firstOfChild.setDependentOpeID(lastOfPresent.getId());
                            naiveDAG.addEdge(lastOfPresent, firstOfChild);
                            childMap.setInnerOperators(subGraph);
                            // since Map only has one input variable which is the variable to be operated on, just directly change the input variable the one of the
                            // parent's one and also the cap on variable should be the parent's
                            // sin
                            childMap.setInputVar(op.getInputVar());
                            childMap.setAppliedVarID(((MapPhysical) op).getAppliedVarID());
                            child.setCapOnVarID(op.getCapOnVarID());
                            childMap.setLocalVarPairID(((MapPhysical) op).getLocalVarPairID());
                            childMap.setElementType(((MapPhysical) op).getElementType());
                            // todo : should change the execution mode. Input should depend on the previous Map and output should depend
                            //  on the child Map
                            // delete the parent node and add the input variable's nodes to the child. The one that serve the input operator should be deleted
                            Set<PhysicalOperator> parents = getParents(naiveDAG, op);
                            parents.remove(lastOfPresent);
                            parents.forEach(parent -> {naiveDAG.addEdge(parent, child);});
                            naiveDAG.removeVertex(op);
                        }
                    }
    //                ((MapPhysical) op).getSubOperators();
                }
            }
        }
    }

//    public static void main(String[] args) {
//        PhysicalOperator x = new BlackBoxPhysical();
//        PhysicalOperator y = new BlackBoxPhysical(x);
//    }

}
